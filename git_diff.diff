diff --git a/scripts/field_check.sh b/scripts/field_check.sh
index 3b7698acb..233d44bf1 100755
--- a/scripts/field_check.sh
+++ b/scripts/field_check.sh
@@ -23,6 +23,8 @@ do
           echo -e "\033[31m ${resourceName}: Compatibility Error! Please check out the correct schema \033[0m"
           error=true
         fi
+
+        go test -v ./scripts/git_diff_test.go -run=TestFieldCompatibilityCheck -file_name="../git_diff.diff"
     fi
 done
 
diff --git a/scripts/markdown_parser.go b/scripts/markdown_parser.go
deleted file mode 100644
index b30fdb105..000000000
--- a/scripts/markdown_parser.go
+++ /dev/null
@@ -1,110 +0,0 @@
-package scripts
-
-import (
-	"fmt"
-	"github.com/sirupsen/logrus"
-	"io/ioutil"
-	"path/filepath"
-	"regexp"
-	"strings"
-)
-
-type Resource struct {
-	Name       string
-	Arguments  map[string]Field
-	Attributes map[string]Field
-}
-
-type Field struct {
-	Name        string
-	Optional    bool
-	Required    bool
-	ForceNew    bool
-	Description string
-}
-
-func parseResourse(filePath string) (*Resource,error) {
-	bytes, err := ioutil.ReadFile(filePath)
-	if err != nil {
-		return nil, fmt.Errorf("resource parsing: %v", err)
-	}
-	name := filepath.Base(filePath)
-	re := regexp.MustCompile("[a-zA-Z_]*")
-	resourceName := "alicloud_" + re.FindString(name)
-	result := &Resource{Name: resourceName, Arguments: nil, Attributes: nil}
-
-	argsRegex := regexp.MustCompile("## Argument Reference")
-	secondLevelRegex := regexp.MustCompile("##")
-	attribRegex := regexp.MustCompile("## Attributes Reference")
-
-	argsRange := argsRegex.FindIndex(bytes)
-	argumentsStart,argumentsEnd := 0,0
-	if argsRange != nil {
-		argumentsStart = argsRange[1]
-	}
-	attributesStart := 0
-	attrRange := attribRegex.FindIndex(bytes[argumentsStart:])
-	if attrRange == nil{
-		logrus.Warningf("the File: %s does not have the Attributes Reference", filePath)
-		return nil,nil
-	}
-	ot := secondLevelRegex.FindIndex(bytes[argumentsStart:])
-	if attrRange != nil {
-		argumentsEnd = attrRange[0] + argumentsStart
-		attributesStart = attrRange[1] + argumentsStart
-	}
-	if ot != nil{
-		argumentsEnd = ot[0] + argumentsStart
-	}
-	var argumentsBytes []byte
-	if argumentsStart <= argumentsEnd {
-		argumentsBytes = bytes[argumentsStart:argumentsEnd]
-	} else {
-		argumentsBytes = make([]byte, 0)
-	}
-	otherRange := secondLevelRegex.FindIndex(bytes[attributesStart:])
-	attributesBytes := bytes[attributesStart:]
-	if otherRange != nil{
-		attributesBytes = bytes[attributesStart:otherRange[0]+attributesStart]
-	}
-	argumentsFieldRegex := regexp.MustCompile("\\* `([a-zA-Z_0-9]*)`[ ]*-? ?(\\(.*\\)) ?(.*)")
-	attributeFieldRegex := regexp.MustCompile("\\* `([a-zA-Z_0-9]*)`[ ]*-?(.*)")
-	attributesMatched := attributeFieldRegex.FindAllSubmatch(attributesBytes, -1)
-	result.Attributes = make(map[string]Field,0)
-	for _, attributeParsed := range attributesMatched {
-		Field := parseMatchLine(attributeParsed,false)
-		result.Attributes[(*Field).Name] = *Field
-	}
-
-	argumentsMatched := argumentsFieldRegex.FindAllSubmatch(argumentsBytes, -1)
-	result.Arguments = make(map[string]Field, 0)
-	for _, argumentMatched := range argumentsMatched {
-		Field := parseMatchLine(argumentMatched,true)
-		result.Arguments[(*Field).Name] = *Field
-	}
-	return result,nil
-}
-
-func parseMatchLine(words [][]byte, argumentFlag bool) *Field {
-	result := &Field{Name: "", Optional: true, Description: ""}
-	if argumentFlag && len(words) >= 4{
-		result.Name = string(words[1])
-		result.Description = string(words[3])
-		if strings.Contains(string(words[2]),"Optional"){
-			result.Optional = true
-		}
-		if strings.Contains(string(words[2]),"Required"){
-			result.Required = true
-		}
-		if strings.Contains(string(words[2]),"ForceNew"){
-			result.ForceNew = true
-		}
-		return result
-	}
-	if !argumentFlag && len(words) >= 3{
-		result.Name = string(words[1])
-		result.Description = string(words[2])
-		return result
-	}
-	return nil
-}
diff --git a/scripts/parser.go b/scripts/parser.go
deleted file mode 100644
index e6b32bea4..000000000
--- a/scripts/parser.go
+++ /dev/null
@@ -1,120 +0,0 @@
-package scripts
-
-import (
-	"bufio"
-	"fmt"
-	log "github.com/sirupsen/logrus"
-	"os"
-	"path/filepath"
-	"regexp"
-	"strings"
-)
-
-type Resource struct {
-	Name       string
-	Arguments  map[string]interface{}
-	Attributes map[string]interface{}
-}
-
-func parseResource(resourceName string) (*Resource, error) {
-	splitRes := strings.Split(resourceName, "alicloud_")
-	if len(splitRes) < 2 {
-		log.Errorf("the resource name parsed failed")
-		return nil, fmt.Errorf("the resource name parsed failed")
-	}
-	basePath := "../website/docs/r/"
-	filePath := strings.Join([]string{basePath, splitRes[1], ".html.markdown"}, "")
-
-	file, err := os.Open(filePath)
-	if err != nil {
-		log.Printf("Cannot open text file: %s, err: [%v]", filePath, err)
-		return nil, err
-	}
-	defer file.Close()
-
-	argsRegex := regexp.MustCompile("## Argument Reference")
-	attribRegex := regexp.MustCompile("## Attributes Reference")
-	secondLevelRegex := regexp.MustCompile("^\\#+")
-	argumentsFieldRegex := regexp.MustCompile("^\\* `([a-zA-Z_0-9]*)`[ ]*-? ?(\\(.*\\)) ?(.*)")
-	attributeFieldRegex := regexp.MustCompile("^\\* `([a-zA-Z_0-9]*)`[ ]*-?(.*)")
-
-	name := filepath.Base(filePath)
-	re := regexp.MustCompile("[a-zA-Z_]*")
-	resourceName = "alicloud_" + re.FindString(name)
-	result := &Resource{Name: resourceName, Arguments: map[string]interface{}{}, Attributes: map[string]interface{}{}}
-	fmt.Printf("The ResourceName = %s\n", resourceName)
-
-	scanner := bufio.NewScanner(file)
-	argumentFlag := false
-	attrFlag := false
-
-	for scanner.Scan() {
-		line := scanner.Text()
-		if argsRegex.MatchString(line) {
-			argumentFlag = true
-			continue
-		}
-		if attribRegex.MatchString(line) {
-			attrFlag = true
-			fmt.Printf("%s\n", line)
-			continue
-		}
-		if argumentFlag {
-			if secondLevelRegex.MatchString(line) {
-				argumentFlag = false
-				continue
-			}
-			argumentsMatched := argumentsFieldRegex.FindAllStringSubmatch(line, 1)
-			for _, argumentMatched := range argumentsMatched {
-				Field := parseMatchLine(argumentMatched, true)
-				if v, exist := Field["Name"]; exist {
-					fmt.Printf("field = %v\n", v)
-					//result.Arguments = append(result.Arguments, Field)
-					result.Arguments[v.(string)]=Field
-				}
-			}
-		}
-
-		if attrFlag {
-			if secondLevelRegex.MatchString(line) {
-				attrFlag = false
-				continue
-			}
-			attributesMatched := attributeFieldRegex.FindAllStringSubmatch(line, 1)
-			for _, attributeParsed := range attributesMatched {
-				Field := parseMatchLine(attributeParsed, false)
-				if v, exist := Field["Name"]; exist {
-					fmt.Printf("field = %v\n", Field["Name"])
-					result.Attributes[v.(string)] = Field
-					//result.Attributes = append(result.Attributes, Field)
-				}
-			}
-		}
-	}
-
-	return result, nil
-}
-
-func parseMatchLine(words []string, argumentFlag bool) map[string]interface{} {
-	result := make(map[string]interface{}, 0)
-	if argumentFlag && len(words) >= 4 {
-		result["Name"] = string(words[1])
-		result["Description"] = string(words[3])
-		if strings.Contains(string(words[2]), "Optional") {
-			result["Optional"] = true
-		}
-		if strings.Contains(string(words[2]), "Required") {
-			result["Required"] = true
-		}
-		if strings.Contains(string(words[2]), "ForceNew") {
-			result["ForceNew"] = true
-		}
-		return result
-	}
-	if !argumentFlag && len(words) >= 3 {
-		result["Name"] = string(words[1])
-		result["Description"] = string(words[2])
-		return result
-	}
-	return nil
-}
diff --git a/scripts/parser_test.go b/scripts/parser_test.go
deleted file mode 100644
index 51f97cd11..000000000
--- a/scripts/parser_test.go
+++ /dev/null
@@ -1,40 +0,0 @@
-package scripts
-
-import (
-	"flag"
-	"github.com/aliyun/terraform-provider-alicloud/alicloud"
-	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
-	log "github.com/sirupsen/logrus"
-	"testing"
-)
-
-var resourceName = flag.String("resource", "", "the name of the terraform resource to diff")
-
-func TestConsistency(t *testing.T) {
-	flag.Parse()
-	if len(*resourceName) == 0 {
-		log.Errorf("The Resource Name is Empty")
-		t.Fatal()
-	}
-	obj := alicloud.Provider().(*schema.Provider).ResourcesMap[*resourceName].Schema
-	objSchema := make(map[string]interface{},0)
-	objMd,err := parseResource(*resourceName)
-	if err != nil{
-		log.Error(err)
-		t.Fatal()
-	}
-	mergeMaps(objSchema,objMd.Attributes,objMd.Arguments)
-	if len(obj)+1 != len(objSchema){
-		log.Errorf("The Field Number of Schema is not consistent with the number in Document")
-		t.Fatal()
-	}
-}
-
-func mergeMaps(Dst map[string]interface{},maps ...map[string]interface{}) map[string]interface{} {
-	for _, m := range maps {
-		for k, v := range m {
-			Dst[k] = v
-		}
-	}
-	return Dst
-}
\ No newline at end of file
diff --git a/scripts/git_diff_test.go b/scripts/schema_test.go
similarity index 54%
rename from scripts/git_diff_test.go
rename to scripts/schema_test.go
index c1cdd490e..2b9276801 100644
--- a/scripts/git_diff_test.go
+++ b/scripts/schema_test.go
@@ -1,19 +1,21 @@
 package scripts
 
 import (
+	"bufio"
 	"flag"
 	"fmt"
+	"github.com/aliyun/terraform-provider-alicloud/alicloud"
+	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
 	log "github.com/sirupsen/logrus"
 	"github.com/waigani/diffparser"
 	"io/ioutil"
+	"os"
+	"path/filepath"
 	"regexp"
 	"strconv"
 	"strings"
 	"testing"
 )
-
-var fileName = flag.String("file_name", "", "the file to check diff")
-
 func init() {
 	customFormatter := new(log.TextFormatter)
 	customFormatter.FullTimestamp = true
@@ -22,10 +24,42 @@ func init() {
 	customFormatter.DisableColors = false
 	customFormatter.ForceColors = true
 	log.SetFormatter(customFormatter)
-	//log.SetOutput(os.Stdout)
+	log.SetOutput(os.Stdout)
 	log.SetLevel(log.DebugLevel)
 }
 
+var (
+	resourceName = flag.String("resource", "", "the name of the terraform resource to diff")
+	fileName = flag.String("file_name", "", "the file to check diff")
+)
+
+type Resource struct {
+	Name       string
+	Arguments  map[string]interface{}
+	Attributes map[string]interface{}
+}
+
+
+func TestConsistency(t *testing.T) {
+	flag.Parse()
+	if len(*resourceName) == 0 {
+		log.Errorf("The Resource Name is Empty")
+		t.Fatal()
+	}
+	obj := alicloud.Provider().(*schema.Provider).ResourcesMap[*resourceName].Schema
+	objSchema := make(map[string]interface{},0)
+	objMd,err := parseResource(*resourceName)
+	if err != nil{
+		log.Error(err)
+		t.Fatal()
+	}
+	mergeMaps(objSchema,objMd.Attributes,objMd.Arguments)
+	if len(obj)+1 != len(objSchema){
+		log.Errorf("The Field Number of Schema is not consistent with the number in Document")
+		t.Fatal()
+	}
+}
+
 func TestFieldCompatibilityCheck(t *testing.T) {
 	flag.Parse()
 	if len(*fileName) == 0 {
@@ -44,7 +78,8 @@ func TestFieldCompatibilityCheck(t *testing.T) {
 			fmt.Printf("FileName = %s\n", file.NewName)
 			for _, hunk := range file.Hunks {
 				if hunk != nil {
-					prev, current := parseHunk(*hunk)
+					prev := ParseField(hunk.OrigRange, hunk.OrigRange.Length)
+					current := ParseField(hunk.NewRange, hunk.NewRange.Length)
 					res = CompatibilityRule(prev, current)
 				}
 			}
@@ -90,13 +125,9 @@ func CompatibilityRule(prev, current map[string]map[string]interface{}) (res boo
 	return
 }
 
-func parseHunk(hunk diffparser.DiffHunk) (map[string]map[string]interface{}, map[string]map[string]interface{}) {
-	prev := parseField(hunk.OrigRange, hunk.OrigRange.Length)
-	current := parseField(hunk.NewRange, hunk.NewRange.Length)
-	return prev, current
-}
 
-func parseField(hunk diffparser.DiffRange, length int) map[string]map[string]interface{} {
+
+func ParseField(hunk diffparser.DiffRange, length int) map[string]map[string]interface{} {
 	schemaRegex := regexp.MustCompile("^\\t*\"([a-zA-Z_]*)\"")
 	typeRegex := regexp.MustCompile("^\\t*Type:\\s+schema.([a-zA-Z]*)")
 	optionRegex := regexp.MustCompile("^\\t*Optional:\\s+([a-z]*),")
@@ -170,3 +201,117 @@ func parseField(hunk diffparser.DiffRange, length int) map[string]map[string]int
 	}
 	return raw
 }
+
+func parseResource(resourceName string) (*Resource, error) {
+	splitRes := strings.Split(resourceName, "alicloud_")
+	if len(splitRes) < 2 {
+		log.Errorf("the resource name parsed failed")
+		return nil, fmt.Errorf("the resource name parsed failed")
+	}
+	basePath := "../website/docs/r/"
+	filePath := strings.Join([]string{basePath, splitRes[1], ".html.markdown"}, "")
+
+	file, err := os.Open(filePath)
+	if err != nil {
+		log.Printf("Cannot open text file: %s, err: [%v]", filePath, err)
+		return nil, err
+	}
+	defer file.Close()
+
+	argsRegex := regexp.MustCompile("## Argument Reference")
+	attribRegex := regexp.MustCompile("## Attributes Reference")
+	secondLevelRegex := regexp.MustCompile("^\\#+")
+	argumentsFieldRegex := regexp.MustCompile("^\\* `([a-zA-Z_0-9]*)`[ ]*-? ?(\\(.*\\)) ?(.*)")
+	attributeFieldRegex := regexp.MustCompile("^\\* `([a-zA-Z_0-9]*)`[ ]*-?(.*)")
+
+	name := filepath.Base(filePath)
+	re := regexp.MustCompile("[a-zA-Z_]*")
+	resourceName = "alicloud_" + re.FindString(name)
+	result := &Resource{Name: resourceName, Arguments: map[string]interface{}{}, Attributes: map[string]interface{}{}}
+	log.Infof("The ResourceName = %s\n", resourceName)
+
+	scanner := bufio.NewScanner(file)
+	argumentFlag := false
+	attrFlag := false
+
+	for scanner.Scan() {
+		line := scanner.Text()
+		if argsRegex.MatchString(line) {
+			argumentFlag = true
+			continue
+		}
+		if attribRegex.MatchString(line) {
+			attrFlag = true
+			fmt.Printf("%s\n", line)
+			continue
+		}
+		if argumentFlag {
+			if secondLevelRegex.MatchString(line) {
+				argumentFlag = false
+				continue
+			}
+			argumentsMatched := argumentsFieldRegex.FindAllStringSubmatch(line, 1)
+			for _, argumentMatched := range argumentsMatched {
+				Field := parseMatchLine(argumentMatched, true)
+				if v, exist := Field["Name"]; exist {
+					log.Infof("field = %v\n", v)
+					//result.Arguments = append(result.Arguments, Field)
+					result.Arguments[v.(string)]=Field
+				}
+			}
+		}
+
+		if attrFlag {
+			if secondLevelRegex.MatchString(line) {
+				attrFlag = false
+				continue
+			}
+			attributesMatched := attributeFieldRegex.FindAllStringSubmatch(line, 1)
+			for _, attributeParsed := range attributesMatched {
+				Field := parseMatchLine(attributeParsed, false)
+				if v, exist := Field["Name"]; exist {
+					log.Infof("field = %v\n", Field["Name"])
+					result.Attributes[v.(string)] = Field
+					//result.Attributes = append(result.Attributes, Field)
+				}
+			}
+		}
+	}
+
+	return result, nil
+}
+
+func parseMatchLine(words []string, argumentFlag bool) map[string]interface{} {
+	result := make(map[string]interface{}, 0)
+	if argumentFlag && len(words) >= 4 {
+		result["Name"] = words[1]
+		result["Description"] = words[3]
+		if strings.Contains(words[2], "Optional") {
+			result["Optional"] = true
+		}
+		if strings.Contains(words[2], "Required") {
+			result["Required"] = true
+		}
+		if strings.Contains(words[2], "ForceNew") {
+			result["ForceNew"] = true
+		}
+		return result
+	}
+	if !argumentFlag && len(words) >= 3 {
+		result["Name"] = words[1]
+		result["Description"] = words[2]
+		return result
+	}
+	return nil
+}
+
+
+
+func mergeMaps(Dst map[string]interface{},maps ...map[string]interface{}) map[string]interface{} {
+	for _, m := range maps {
+		for k, v := range m {
+			Dst[k] = v
+		}
+	}
+	return Dst
+}
\ No newline at end of file
